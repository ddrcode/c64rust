use crate::c64::*;

fn asm_test(prog: &[u8], res: u8, flags: u8) {
    let mut c64 = C64::new();
    c64.cpu.registers.counter = 0x0300;
    c64.load(prog, 0x0300);
    c64.next();
    c64.next();
    assert_eq!(res, c64.A8());
    assert_eq!(flags, u8::from(&c64.P())); // NV1BDIZC
}

#[test]
fn test_adcd() {
    asm_test(&[0xa9, 0x50, 0x69, 0x10], 0x60, 0b00100000);
    asm_test(&[0xa9, 0x50, 0x69, 0x50], 0xa0, 0b11100000);
    asm_test(&[0xa9, 0x50, 0x69, 0x90], 0xe0, 0b10100000);
    asm_test(&[0xa9, 0x50, 0x69, 0xd0], 0x20, 0b00100001);
    asm_test(&[0xa9, 0xd0, 0x69, 0x10], 0xe0, 0b10100000);
    asm_test(&[0xa9, 0xd0, 0x69, 0x50], 0x20, 0b00100001);
    asm_test(&[0xa9, 0xd0, 0x69, 0x90], 0x60, 0b01100001);
    asm_test(&[0xa9, 0xd0, 0x69, 0xd0], 0xa0, 0b10100001);
}

#[test]
fn test_sbc() {
    asm_test(&[0xa9, 0xf0, 0xe9, 0x07], 0xf0-0x07, 0b10100001);
    // scenarios from: https://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
    asm_test(&[0xa9, 0x50, 0xe9, 0xf0], 0x60, 0b00100000);
    asm_test(&[0xa9, 0x50, 0xe9, 0xb0], 0xa0, 0b11100000);
    asm_test(&[0xa9, 0x50, 0xe9, 0x70], 0xe0, 0b10100000);
    asm_test(&[0xa9, 0x50, 0xe9, 0x30], 0x20, 0b00100001);
    asm_test(&[0xa9, 0xd0, 0xe9, 0xf0], 0xe0, 0b10100000);
    asm_test(&[0xa9, 0xd0, 0xe9, 0xb0], 0x20, 0b00100001);
    asm_test(&[0xa9, 0xd0, 0xe9, 0x70], 0x60, 0b01100001);
    asm_test(&[0xa9, 0xd0, 0xe9, 0x30], 0xa0, 0b10100001);
}

